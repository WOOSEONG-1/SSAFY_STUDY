*** B형 : 3. 16
*** A형 : 3. 4
** 24. 01. 29 ~ 24 . 02. 02 ( 4주차 )
1. DP or 탐색	-> 6 / 5
2. Dijkstra 		->	0 / 5
3. Greedy		-> 0 / 5
4. Bitmasking 	-> 3 / 5
** 예 정 **
1. Segment Tree
2. Two-Pointer
3. MST
----------------------------------------------------------------------------------------

* 수업 노트 ( 1. 17 ( 수) )
	** 함수와 조건문 I
		-	'외장함수'라는 단어는 없음
		- """ 주석은 함수 내에서 documnet string (docstring) 이라 불림 : 함수의 가이드 역할 / 사용 자제
		- 매개변수 : 함수를 정의할 때 함수가 받을 값, 인자 : 함수를 호출할 때 대입하는 값
		- 위치 > 기본 > 가변 > 가변 키워드가 권장
		- lambda : 익명 함수, 한 줄로 함수를 표현
----------------------------------------------------------------------------------------
* 수업 노트 ( 1. 18 ( 목) )
	** 함수와 조건문 II
		- from math import sqrt	 \n from my_math import sqrt 라면 마지막으로 import된 것으로 overwrite

----------------------------------------------------------------------------------------
* 수업 노트 ( 1. 19 ( 금 ) )
	** 금융 데이터를 활용한 금융 상품 비교 애플리케이션
		- 가장 hot한 상품들, 신규 상품들 게재
		- 금융상품통합비교 공시 API
	** 	open api와 외부 데이터를 활용한 영화 추천 서비스
		-
	- 인터넷에 있는 날씨 정보를 가져와, 내가 원하는 정보만 출력
	- OpenWeatherMap API
	- 도전 과제 : gitlab에 제출
	- 파이썬으로 정기 예금 데이터 수집 및 미션 수행
	- 외부 서버를 활용한 데이터 수집
	- 요구 사항에 맞게 데이터 가공
----------------------------------------------------------------------------------------
* 수업 노트 ( 1. 23 ( 화 ) )
	- 해시 함수 : 정수형은 정수 그대로의 hash 값을 가진다.
	- 문자열은 항상 다르다.
	
* 알고리즘
	- 조합(Combination) 구현 ( n C r )
	comb( int[] arr, boolean[] brr, int k, int n, int r )
	if ( r == 0 ) print(arr, brr, n )
	for ( i = k ; i < n ; i++ ) {
		brr[k] = true
		comb(arr,brr,i+1, n, r-1)
		brr[k] = false
	}

----------------------------------------------------------------------------------------
* 수업 노트 ( 1. 24 ( 수 ) )
	- 클래스로 만든 객체 : 인스턴스
	Ex) 클래스(가수) - 인스턴스(아이유) => 클래스와 인스턴스 = 객체
	- 클래스의 앞 문자는 대문자 -> Paskal Case <-> Snake Case(소문자 = 함수)
----------------------------------------------------------------------------------------
* 수업 노트 ( 2. 1 ( 목 ) )
	- 자료구조 : 배열
		- 접근 : O(1)
		- 탐색 : O(n)
		- 삽입 : O(1), O(n)(사이에 추가할 때)
		- 삭제 : O(1), O(n)(사이를 제거할 때)

* 수업 노트 (2. 2 ( 금 ) )
	- LCS ( 최장 공통 수열 )
	
		** 도출 Code
		if ( i == j ) 	dp[i][j] = dp[i-1][j-1] + 1
		else			dp[i][j] = Max( dp[i][j-1], d[i-1][j] )
		
		** 출력 Code
		while ( i > 0 && j > 0 )
			if ( s1[i] == s2[j] ) 
				append(s1)
				i--;	j--;
			else if ( dp[i-1][j] > dp[i][j-1] )
				i--;
			else 	
				j--;
			
Q?
	- 알고리즘( ~~기간, 어떤?, 코딩 환경 스레드 ( 단일, 멀티 )
	- 함수의 인자는 어떤 것을 주는게 좋은지 ( 판단 기준 )
		Ex) 배열 탐색 큐 BFS : static Queue, n, m, 
	- 

최대 5번 이동해서 만들 수 있는 블록의 가장 큰 값 -> 깊이 5 백트 -> maxv = 16이면 break
* 좌우 : 한 행씩 계산
	- 진행 방향쪽부터 배열 채우기
	- M[a][b]<-> M[a][b+1] 을 비교, 같으면 M[a][0] or M[a][n-1] 채우기
	- 같으면 b+2 b+3 비교, 다르면 b+1, b+2 비교
* 상하 : 한 열씩 계산

각 배열 순회 -> 다음 수가 다르면 확인 ( -1인지 ) -> -1이면 그 다음 수가 n번
이어지는지 확인 -> ok면 cnt +1

import java.io.IOException;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

/*  1. 아이디어
        - i,j 에 대한 bfs , 1을 만나면 i,j,k+1 을 큐에 대입
    2. 시간복잡도
        - O(V+E) = 5,000,000
    3. 자료 구조
        - 배열 : 탐색 -> O(n) / 접근 -> O(1) / 삭제 : O(1) / 삽입 : O(1)
 */
#1 7

#2 4

#3 11

#4 11

#5 15

#6 4

#7 4

#8 1

#9 5

#10 8

import sys
sys.stdin = open('C:/temp/input.txt', 'r')
MV = 10000000
for t in range(1, int(input())+1):
    n, x = map(int, input().split())
    A = [[*map(int, input().split())] for _ in range(n)]
    cnt = 0
    for i in range(n):
        if t == 6:
            t = 6

        ramp = 0
        for j in range(n-1):
            # 다음 수가 크면
            if A[i][j] == A[i][j+1] - 1:
                # 앞만 검사
                if x-1 <= j:
                    for k in range(x):
                        if A[i][j] != A[i][j-k]:
                            ramp = MV
                            break
                else:
                    ramp = MV
                    break
            # 다음 수가 작으면
            elif A[i][j] == A[i][j+1] + 1:
                # 뒤만 검사
                if j <= n-x-1:
                    for k in range(x):
                        if A[i][j+1] != A[i][j+1+k]:
                            ramp = MV
                            break
                else:
                    ramp = MV
                    break
            elif abs(A[j][i] - A[j+1][i]) > 1:
                ramp = MV
                break
        if ramp == 0:
            cnt += 1

        ramp = 0
        for j in range(n - 1):
            # 다음 수가 크면
            if A[j][i] == A[j+1][i] - 1:
                # 앞만 검사
                if x - 1 <= j:
                    for k in range(x):
                        if A[j][i] != A[j-k][i]:
                            ramp = MV
                            break
                else:
                    ramp = MV
                    break
            # 다음 수가 작으면
            elif A[j][i] == A[j+1][i] + 1:
                # 뒤만 검사
                if j <= n - x - 1:
                    for k in range(x):
                        if A[j+1][i] != A[j+1+k][i]:
                            ramp = MV
                            break
                else:
                    ramp = MV
                    break
            elif abs(A[j][i] - A[j+1][i]) > 1:
                ramp = MV
                break
        if ramp == 0:
            cnt += 1

    print(f"#{t} {cnt}")